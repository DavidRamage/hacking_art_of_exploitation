To set the register format to Intel do set disassembly-flavor intel (slight difference from book)

info registers command dumps register contents
break <functionname> sets a breakpoint at the given function:

(gdb) break main
Breakpoint 1 at 0x40052e: file firstprog.c, line 5.

run - run program
gdb) run
Starting program: /home/david/hacking_the_art_of_exploitation/Chapter_2/firstprog 

Breakpoint 1, main () at firstprog.c:5
5	    for (i=0; i<10; i++) {
(gdb) 


Info registers displays register content
gdb) info registers
rax            0x400526	4195622
rbx            0x0	0
rcx            0x0	0
rdx            0x7fffffffde58	140737488346712
rsi            0x7fffffffde48	140737488346696
rdi            0x1	1
rbp            0x7fffffffdd60	0x7fffffffdd60
rsp            0x7fffffffdd50	0x7fffffffdd50
r8             0x4005d0	4195792
r9             0x7ffff7de7ab0	140737351940784
r10            0x846	2118
r11            0x7ffff7a2d740	140737348032320
r12            0x400430	4195376
r13            0x7fffffffde40	140737488346688
r14            0x0	0
r15            0x0	0
rip            0x40052e	0x40052e <main+8>
eflags         0x206	[ PF IF ]
cs             0x33	51
ss             0x2b	43
ds             0x0	0
es             0x0	0
fs             0x0	0
gs             0x0	0


This differs from the book because they're 64 bit registers here.  RAX, RCX, RDX, and RBX are general purpose registers:

RAX - Accumulator
RCX - Counter
RDX - Data
RBX - Base

Similarly:
RSP - Stack Pointer
RBP - Base Pointer
RSI - Source Index
RDI - Destination Index

The first two are pointers as they store memory addresses.
The second two are also pointers because they point to the source and destination from where data is read and written

list displays the code of the program if the debugging symbols were enabled at compile time

(gdb) list
1	#include <stdio.h>
2	
3	int main() {
4	    int i;
5	    for (i=0; i<10; i++) {
6	        printf("Hello, world!\n");
7	    }
8	    return 0;
9	}
(gdb) 


To get thecontent of a single register
(gdb) info register rip
rip            0x40052e	0x40052e <main+8>

This can be truncated to i r


Note that rip contains a memory address.  You can directly examine it with x (these are all the same, just formatting differences)
(gdb) x/x 0x40052e
0x40052e <main+8>:	0x00fc45c7
(gdb) 
(gdb) x/o 0x40052e
0x40052e <main+8>:	077042707
(gdb) x/u 0x40052e
0x40052e <main+8>:	16532935
(gdb) x/t 0x40052e
0x40052e <main+8>:	00000000111111000100010111000111


You can also read pointer values by prefacing the register name with $
(gdb) x/x $rip
0x40052e <main+8>:	0x00fc45c7
(gdb) 


You can also have gdb look at a number of words starting at a given starting point:
gdb) x/2x $rip
0x40052e <main+8>:	0x00fc45c7	0xeb000000
(gdb) x/3x $rip
0x40052e <main+8>:	0x00fc45c7	0xeb000000	0x05e4bf0e
(gdb) x/5x $rip
0x40052e <main+8>:	0x00fc45c7	0xeb000000	0x05e4bf0e	0xbfe80040
0x40053e <main+24>:	0x83fffffe
(gdb) x/12x $rip
0x40052e <main+8>:	0x00fc45c7	0xeb000000	0x05e4bf0e	0xbfe80040
0x40053e <main+24>:	0x83fffffe	0x8301fc45	0x7e09fc7d	0x0000b8ec
0x40054e <main+40>:	0xc3c90000	0x1f0f2e66	0x00000084	0x1f0f0000


Sizes other than words can be used too.
Single byte:
(gdb) x/xb $rip
0x40052e <main+8>:	0xc7
(gdb) 

Half a word:
(gdb) x/xh $rip
0x40052e <main+8>:	0x45c7
(gdb) 

Full word:
(gdb) x/xw $rip
0x40052e <main+8>:	0x00fc45c7
(gdb) 

Giant word (two words):
(gdb) x/xg $rip
0x40052e <main+8>:	0xeb00000000fc45c7
(gdb) 

Note the little-endian crap

To look at executable code in memory:

(gdb) i r $rip
rip            0x40052e	0x40052e <main+8>

The x command looks at memory like i looks at registers
(gdb) x/i $rip
=> 0x40052e <main+8>:	mov    DWORD PTR [rbp-0x4],0x0  #i means instruction
(gdb) x/3i $rip
=> 0x40052e <main+8>:	mov    DWORD PTR [rbp-0x4],0x0
   0x400535 <main+15>:	jmp    0x400545 <main+31>
   0x400537 <main+17>:	mov    edi,0x4005e4
(gdb) x/7xb $rip
0x40052e <main+8>:	0xc7	0x45	0xfc	0x00	0x00	0x00	0x00
(gdb) x/i $rip
=> 0x40052e <main+8>:	mov    DWORD PTR [rbp-0x4],0x0

We can set a variable using the print command:
(gdb) print $rbp -4
$1 = (void *) 0x7fffffffdd5c
(gdb)

We can also examine it this way:
(gdb) x/4xb $1
0x7fffffffdd5c:	0x00	0x00	0x00	0x00

nexti will run the next command and advance the instruction pointer
(gdb) i r rip
rip            0x40052e	0x40052e <main+8>
(gdb) nexti
0x0000000000400535	5	    for (i=0; i<10; i++) {
(gdb) i r rip
rip            0x400535	0x400535 <main+15>
(gdb) nexti
0x0000000000400545	5	    for (i=0; i<10; i++) {
(gdb) i r rip
rip            0x400545	0x400545 <main+31>
(gdb) nexti
0x0000000000400549	5	    for (i=0; i<10; i++) {
(gdb) i r rip
rip            0x400549	0x400549 <main+35>
(gdb) nexti
6	        printf("Hello, world!\n");

Note that the debugging symbols are enabled

If it is suspected that a memory area contains ASCII, the B switch can be added to x

(gdb) x/6cb 0x4005e4
0x4005e4:	72 'H'	101 'e'	108 'l'	108 'l'	111 'o'	44 ','


To dump assembly

(gdb) disass main
Dump of assembler code for function main:
   0x0000000000400526 <+0>:	push   rbp
   0x0000000000400527 <+1>:	mov    rbp,rsp
   0x000000000040052a <+4>:	sub    rsp,0x10
=> 0x000000000040052e <+8>:	mov    DWORD PTR [rbp-0x4],0x0
   0x0000000000400535 <+15>:	jmp    0x400545 <main+31>
   0x0000000000400537 <+17>:	mov    edi,0x4005e4
   0x000000000040053c <+22>:	call   0x400400 <puts@plt>
   0x0000000000400541 <+27>:	add    DWORD PTR [rbp-0x4],0x1
   0x0000000000400545 <+31>:	cmp    DWORD PTR [rbp-0x4],0x9
   0x0000000000400549 <+35>:	jle    0x400537 <main+17>
   0x000000000040054b <+37>:	mov    eax,0x0
   0x0000000000400550 <+42>:	leave  
   0x0000000000400551 <+43>:	ret    
End of assembler dump.


To make gdb take the next step do "nexti"

The livecd that the book comes with uses a 486 built toolchain, and the part where gdb descends into the strcpy function does not happen on a modern one.


& is the address-of operator in gdb.  We have a variable called "pointer" (which is a pointer) 
gdb) x/xw &pointer
0x7fffffffdd30:	0xffffdd40
This means that pointer is at the address 0x7fffffffdd30 and it contains the address 0xffffdd40

Good example of pointer behavior is with this very simple program:

(gdb) list
1	#include <stdio.h>
2	int main() {
3	    int int_var = 5;
4	    int *int_ptr;
5	    int_ptr = &int_var;
6	}
(gdb) break 6
Breakpoint 1 at 0x400571: file addressof.c, line 6.
(gdb) run
Starting program: /home/david/hacking_the_art_of_exploitation/Chapter_2/a.out 

Breakpoint 1, main () at addressof.c:6
6	}
(gdb) print int_var
$1 = 5
(gdb) print &int_var
$2 = (int *) 0x7fffffffdd5c
(gdb) print int_ptr
$3 = (int *) 0x7fffffffdd5c
(gdb) print &int_ptr
$4 = (int **) 0x7fffffffdd60

Another operator in gdb is the dereference operator (*).  This follows a pointer to the memory address it points to and returns that address's value;

(gdb) print *int_ptr
$5 = 5


This is GDB output from a segmentation fault of convert2.c when compiled at only 32 bit


Reading symbols from convert2...done.
(gdb) break main
Breakpoint 1 at 0x804844f: file convert2.c, line 7.
(gdb) run test
Starting program: /home/david/hacking_the_art_of_exploitation/Chapter_2/convert2 test

Breakpoint 1, main (argc=2, argv=0xffffcfe4) at convert2.c:7
7	    count = atoi(argv[2]);
(gdb) continue
Continuing.

Program received signal SIGSEGV, Segmentation fault.
0xf7e21e1b in ?? () from /lib32/libc.so.6
(gdb) where
#0  0xf7e21e1b in ?? () from /lib32/libc.so.6
#1  0xf7e21c89 in strtol () from /lib32/libc.so.6
#2  0xf7e1f060 in atoi () from /lib32/libc.so.6
#3  0x08048460 in main (argc=2, argv=0xffffcfe4) at convert2.c:7
(gdb) x/3w 0xffffcfe4
0xffffcfe4:	-11832	-11769	0


This sigsevs because argv[2] is a pointer with a zero in it, so it points to an invalid memory address
