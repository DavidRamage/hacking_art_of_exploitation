Text/code segment of memory contains assembled machine instructions.
Execution of instructions is nonlinear due to jumps and branches.

When the program executes,  EIP/RIP is set to the first instruction.
The following loop then occurs

1 - The instruction that EIP/RIP points to is read.
2 - The byte length of the instruction  is added to EIP/RIP
3 - The instruction read in step 1 is executed.
4 - Go back to step 1.

If the instruction is a jump or call instruction, the EIP will be changed
to point to a different memory address.

The text segment of memory has write protection disabled.

The data segment of memory is used to store initialized global and static
variables.

The BSS segment is filled with uninitialized variables.  

Both data and BSS are writable, but they have a fixed size.

The heap segment of memory is directly controlled by the programmer.  Heap can
grow and shrink as needed.

The stack is also of variable size.  It is used to store local function variables
and context during function calls.

Since the function is at its own place in the text segment, the stack contains
all of the variables passed to it and the place that EIP/RIP needs to be set to
after the function returns, as well as all local variables in the fuction.
This collection of information is called the stack frame.

The ESP/RSP register is a pointer to the end of the stack.

When a function is called, several things are pushed together in the stack frame.
The RBP/EBP register (Base Pointer) is used to reference local function vars 
in the current stack frame.

Each stack frame contains the function's parameters, its local variables, and two
pointers to put stuff back how it was before.

Saved Frame Pointer - SFP - is used to restore the EBP/RBP to its previous value.
Return Address is used to restore EIP to the next instruction after the 
function call.


The assembler output varies from that in the book 

(gdb) disass main
Dump of assembler code for function main:
   0x0804846b <+0>:	lea    ecx,[esp+0x4]
   0x0804846f <+4>:	and    esp,0xfffffff0
   0x08048472 <+7>:	push   DWORD PTR [ecx-0x4]
   0x08048475 <+10>:	push   ebp //push ebp onto stack
   0x08048476 <+11>:	mov    ebp,esp
   0x08048478 <+13>:	push   ecx //push ecx onto stack
   0x08048479 <+14>:	sub    esp,0x4 //subtract 4 from stack pointer
   0x0804847c <+17>:	push   0x4 //push 4 onto stack
   0x0804847e <+19>:	push   0x3 //push 3 onto stack
   0x08048480 <+21>:	push   0x2 //push 2 onto stack
   0x08048482 <+23>:	push   0x1 //push 1 onto stack
   0x08048484 <+25>:	call   0x804843b <test_function> //call the test_function
   0x08048489 <+30>:	add    esp,0x10 //increment stack pointer by 16
   0x0804848c <+33>:	mov    eax,0x0 
   0x08048491 <+38>:	mov    ecx,DWORD PTR [ebp-0x4]
   0x08048494 <+41>:	leave  
   0x08048495 <+42>:	lea    esp,[ecx-0x4]
   0x08048498 <+45>:	ret    
End of assembler dump.

Dump of assembler code for function test_function:
   0x0804843b <+0>:	push   ebp //push base pointer onto stack
   0x0804843c <+1>:	mov    ebp,esp //overwrite base pointer with stack pointer
   0x0804843e <+3>:	sub    esp,0x28 //decrement stack pointer
   0x08048441 <+6>:	mov    eax,gs:0x14
   0x08048447 <+12>:	mov    DWORD PTR [ebp-0xc],eax
   0x0804844a <+15>:	xor    eax,eax
   0x0804844c <+17>:	mov    DWORD PTR [ebp-0x1c],0x7a69
   0x08048453 <+24>:	mov    BYTE PTR [ebp-0x16],0x41
   0x08048457 <+28>:	nop
   0x08048458 <+29>:	mov    eax,DWORD PTR [ebp-0xc]
   0x0804845b <+32>:	xor    eax,DWORD PTR gs:0x14
   0x08048462 <+39>:	je     0x8048469 <test_function+46>
   0x08048464 <+41>:	call   0x8048310 <__stack_chk_fail@plt>
   0x08048469 <+46>:	leave  
   0x0804846a <+47>:	ret    
End of assembler dump.


It is important to remember that the "bottom" of the stack has numerically
higher memory addresses.  Further upward you have lower addresses.
